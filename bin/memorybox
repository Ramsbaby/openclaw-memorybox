#!/bin/bash
# memorybox â€” Zero-dependency memory management CLI for OpenClaw
# Usage: memorybox <command> [workspace_path]
# Commands: analyze, split, archive, report, health

set -euo pipefail

VERSION="2.0.0"
DEFAULT_WORKSPACE="${OPENCLAW_WORKSPACE:-$HOME/openclaw}"
MAX_MEMORY_BYTES=10000
WARN_THRESHOLD=80  # percent
ARCHIVE_DAYS=14

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
# BLUE='\033[0;34m'  # reserved
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

usage() {
  cat <<EOF
${BOLD}ğŸ§  MemoryBox v${VERSION}${NC} â€” Smart memory management for OpenClaw

${BOLD}Usage:${NC}
  memorybox <command> [workspace_path]

${BOLD}Commands:${NC}
  ${GREEN}analyze${NC}    Analyze MEMORY.md structure, find bloat, suggest splits
  ${GREEN}split${NC}      Interactive: split large MEMORY.md sections into domain files
  ${GREEN}archive${NC}    Move old daily logs (${ARCHIVE_DAYS}+ days) to archive/
  ${GREEN}report${NC}     Generate before/after impact report
  ${GREEN}health${NC}     Quick health check (size, structure, recommendations)
  ${GREEN}dedupe${NC}     Find duplicate content across memory files
  ${GREEN}stale${NC}      Find outdated/stale content and date references
  ${GREEN}suggest${NC}    Smart suggestions for memory improvement
  ${GREEN}init${NC}       Initialize 3-Tier structure in a workspace
  ${GREEN}doctor${NC}     Full diagnostic (health + dedupe + stale + suggest)

${BOLD}Options:${NC}
  -w, --workspace PATH    Set workspace path (default: \$OPENCLAW_WORKSPACE or ~/openclaw)
  -d, --days N            Archive threshold in days (default: ${ARCHIVE_DAYS})
  -m, --max-bytes N       MEMORY.md size target (default: ${MAX_MEMORY_BYTES})
  -h, --help              Show this help
  -v, --version           Show version

${BOLD}Examples:${NC}
  memorybox analyze
  memorybox split ~/openclaw
  memorybox archive --days 7
  memorybox health

EOF
}

# Parse global options
WORKSPACE="$DEFAULT_WORKSPACE"
while [[ $# -gt 0 ]]; do
  case $1 in
    -w|--workspace) WORKSPACE="$2"; shift 2 ;;
    -d|--days) ARCHIVE_DAYS="$2"; shift 2 ;;
    -m|--max-bytes) MAX_MEMORY_BYTES="$2"; shift 2 ;;
    -h|--help) usage; exit 0 ;;
    -v|--version) echo "memorybox v${VERSION}"; exit 0 ;;
    *) break ;;
  esac
done

COMMAND="${1:-help}"
shift 2>/dev/null || true

# Allow workspace as positional arg after command
if [[ -n "${1:-}" && "${1:-}" != -* ]]; then
  WORKSPACE="$1"
  shift 2>/dev/null || true
fi

MEMORY_FILE="$WORKSPACE/MEMORY.md"
MEMORY_DIR="$WORKSPACE/memory"

validate_workspace() {
  if [[ ! -d "$WORKSPACE" ]]; then
    echo -e "${RED}Error: Workspace not found: $WORKSPACE${NC}"
    echo "Set OPENCLAW_WORKSPACE or use -w flag"
    exit 1
  fi
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ANALYZE: Deep analysis of MEMORY.md
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cmd_analyze() {
  validate_workspace
  echo -e "${BOLD}ğŸ” MemoryBox Analysis${NC}"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo -e "${DIM}Workspace: $WORKSPACE${NC}"
  echo ""

  # MEMORY.md analysis
  if [[ ! -f "$MEMORY_FILE" ]]; then
    echo -e "${YELLOW}âš ï¸  MEMORY.md not found${NC}"
    return
  fi

  local total_bytes
  total_bytes=$(wc -c < "$MEMORY_FILE")
  local total_lines
  total_lines=$(wc -l < "$MEMORY_FILE")
  local pct=$((total_bytes * 100 / MAX_MEMORY_BYTES))

  echo -e "${BOLD}ğŸ“„ MEMORY.md${NC}"
  if [[ $total_bytes -gt $MAX_MEMORY_BYTES ]]; then
    echo -e "   Size: ${RED}${total_bytes} bytes (${pct}% of ${MAX_MEMORY_BYTES} target) ğŸš¨ OVER LIMIT${NC}"
  elif [[ $pct -gt $WARN_THRESHOLD ]]; then
    echo -e "   Size: ${YELLOW}${total_bytes} bytes (${pct}% of ${MAX_MEMORY_BYTES} target) âš ï¸${NC}"
  else
    echo -e "   Size: ${GREEN}${total_bytes} bytes (${pct}% of ${MAX_MEMORY_BYTES} target) âœ…${NC}"
  fi
  echo "   Lines: $total_lines"
  echo ""

  # Section analysis
  echo -e "${BOLD}ğŸ“Š Sections by Size${NC}"
  echo ""

  local current_section=""
  local current_size=0
  local section_count=0
  local -a sections=()
  local -a sizes=()

  while IFS= read -r line; do
    if [[ "$line" =~ ^##[[:space:]] ]]; then
      if [[ -n "$current_section" ]]; then
        sections+=("$current_section")
        sizes+=("$current_size")
        section_count=$((section_count + 1))
      fi
      current_section="${line#\#\# }"
      current_size=${#line}
    else
      current_size=$((current_size + ${#line} + 1))
    fi
  done < "$MEMORY_FILE"

  # Last section
  if [[ -n "$current_section" ]]; then
    sections+=("$current_section")
    sizes+=("$current_size")
    section_count=$((section_count + 1))
  fi

  # Sort by size (descending) and display
  if [[ $section_count -gt 0 ]]; then
    # Create temp file for sorting
    local tmpfile
    tmpfile=$(mktemp)
    for i in "${!sections[@]}"; do
      local spct=$((sizes[i] * 100 / total_bytes))
      echo "${sizes[i]}|${spct}|${sections[i]}" >> "$tmpfile"
    done

    sort -t'|' -k1 -rn "$tmpfile" | head -15 | while IFS='|' read -r size spct name; do
      local bar=""
      local bar_len=$((spct / 3))
      for ((j=0; j<bar_len; j++)); do bar+="â–ˆ"; done

      if [[ $size -gt 3000 ]]; then
        echo -e "   ${RED}${bar}${NC} ${name}"
        echo -e "   ${DIM}${size} bytes (${spct}%)${NC} â†’ ${YELLOW}suggest: memory/domains/$(echo "$name" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g').md${NC}"
      elif [[ $size -gt 1500 ]]; then
        echo -e "   ${YELLOW}${bar}${NC} ${name}"
        echo -e "   ${DIM}${size} bytes (${spct}%)${NC}"
      else
        echo -e "   ${GREEN}${bar}${NC} ${name}"
        echo -e "   ${DIM}${size} bytes (${spct}%)${NC}"
      fi
      echo ""
    done

    rm -f "$tmpfile"
  fi

  # Memory directory analysis
  echo -e "${BOLD}ğŸ“ Memory Directory${NC}"
  echo ""

  local daily_count=0
  local oldest_daily=""
  local total_files=0

  if [[ -d "$MEMORY_DIR" ]]; then
    daily_count=$(find "$MEMORY_DIR" -maxdepth 1 -name "202?-??-??.md" 2>/dev/null | wc -l | tr -d ' ')
    oldest_daily=$(find "$MEMORY_DIR" -maxdepth 1 -name "202?-??-??.md" 2>/dev/null | sort | head -1 | xargs basename 2>/dev/null || echo "none")
    total_files=$(find "$MEMORY_DIR" -type f 2>/dev/null | wc -l | tr -d ' ')

    echo "   Total files: $total_files"
    echo "   Daily logs: $daily_count (oldest: ${oldest_daily%.md})"

    for d in domains projects drafts reports incidents archive; do
      if [[ -d "$MEMORY_DIR/$d" ]]; then
        local count
        count=$(find "$MEMORY_DIR/$d" -type f 2>/dev/null | wc -l | tr -d ' ')
        echo -e "   ${d}/: ${count} files"
      fi
    done

    # Find old daily logs
    local old_count
    old_count=$(find "$MEMORY_DIR" -maxdepth 1 -name "202?-??-??.md" -mtime +${ARCHIVE_DAYS} 2>/dev/null | wc -l | tr -d ' ')
    if [[ $old_count -gt 0 ]]; then
      echo ""
      echo -e "   ${YELLOW}âš ï¸  ${old_count} daily logs older than ${ARCHIVE_DAYS} days${NC}"
      echo -e "   ${DIM}Run: memorybox archive${NC}"
    fi
  else
    echo -e "   ${YELLOW}âš ï¸  memory/ directory not found${NC}"
  fi

  # Flat file detection (files that should be in subdirectories)
  echo ""
  local flat_files=0
  if [[ -d "$MEMORY_DIR" ]]; then
    while IFS= read -r f; do
      local basename
      basename=$(basename "$f")
      # Skip daily logs, README, JSON state files
      if [[ "$basename" =~ ^202[0-9]-[0-9]{2}-[0-9]{2}\.md$ ]] || \
         [[ "$basename" == "README.md" ]] || \
         [[ "$basename" =~ \.json$ ]]; then
        continue
      fi
      flat_files=$((flat_files + 1))
    done < <(find "$MEMORY_DIR" -maxdepth 1 -name "*.md" -not -name "README.md" 2>/dev/null)

    if [[ $flat_files -gt 0 ]]; then
      echo -e "${YELLOW}âš ï¸  ${flat_files} non-daily files in memory/ root${NC}"
      echo -e "${DIM}   These should be in domains/, projects/, drafts/, or reports/${NC}"
    fi
  fi

  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SPLIT: Interactive section splitting
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cmd_split() {
  validate_workspace

  if [[ ! -f "$MEMORY_FILE" ]]; then
    echo -e "${RED}Error: MEMORY.md not found${NC}"
    exit 1
  fi

  local total_bytes
  total_bytes=$(wc -c < "$MEMORY_FILE")

  if [[ $total_bytes -le $MAX_MEMORY_BYTES ]]; then
    echo -e "${GREEN}âœ… MEMORY.md is already under ${MAX_MEMORY_BYTES} bytes (${total_bytes} bytes)${NC}"
    echo "No splitting needed."
    return
  fi

  echo -e "${BOLD}âœ‚ï¸  MemoryBox Split${NC}"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo -e "MEMORY.md: ${RED}${total_bytes} bytes${NC} (target: ${MAX_MEMORY_BYTES})"
  echo -e "Need to move: $((total_bytes - MAX_MEMORY_BYTES)) bytes"
  echo ""

  mkdir -p "$MEMORY_DIR/domains"

  # Parse sections
  local -a section_names=()
  local -a section_starts=()
  local -a section_sizes=()
  local line_num=0
  local current_start=0
  local current_name=""
  # local prev_start=0

  while IFS= read -r line; do
    line_num=$((line_num + 1))
    if [[ "$line" =~ ^##[[:space:]] ]]; then
      if [[ -n "$current_name" ]]; then
        section_names+=("$current_name")
        section_starts+=("$current_start")
      fi
      current_name="${line#\#\# }"
      current_start=$line_num
    fi
  done < "$MEMORY_FILE"
  if [[ -n "$current_name" ]]; then
    section_names+=("$current_name")
    section_starts+=("$current_start")
  fi

  # Calculate sizes
  local total_sections=${#section_names[@]}
  for ((i=0; i<total_sections; i++)); do
    local start=${section_starts[i]}
    local end
    if [[ $((i + 1)) -lt $total_sections ]]; then
      end=$((section_starts[i+1] - 1))
    else
      end=$line_num
    fi
    local content
    content=$(sed -n "${start},${end}p" "$MEMORY_FILE")
    section_sizes+=("${#content}")
  done

  # Show large sections and ask
  local moved_bytes=0
  for ((i=0; i<total_sections; i++)); do
    if [[ ${section_sizes[i]} -gt 2000 ]]; then
      local slug
      slug=$(echo "${section_names[i]}" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g' | head -c 40)
      local target_file="$MEMORY_DIR/domains/${slug}.md"

      echo -e "${YELLOW}Section: ${section_names[i]}${NC}"
      echo -e "Size: ${section_sizes[i]} bytes"
      echo -e "Target: memory/domains/${slug}.md"

      read -rp "Move this section? [Y/n/s(kip all)] " answer
      case "$answer" in
        n|N) echo "Skipped."; echo "" ;;
        s|S) echo "Skipping remaining."; break ;;
        *)
          # Extract section
          local start=${section_starts[i]}
          local end
          if [[ $((i + 1)) -lt $total_sections ]]; then
            end=$((section_starts[i+1] - 1))
          else
            end=$line_num
          fi

          # Write to domain file
          {
            echo "# ${section_names[i]}"
            echo ""
            echo "> Separated from MEMORY.md by MemoryBox. Searchable via memory_search."
            echo ""
            sed -n "$((start + 1)),${end}p" "$MEMORY_FILE"
          } > "$target_file"

          echo -e "${GREEN}âœ… Written to ${target_file}${NC}"
          moved_bytes=$((moved_bytes + section_sizes[i]))
          echo ""
          ;;
      esac
    fi
  done

  if [[ $moved_bytes -gt 0 ]]; then
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo -e "${GREEN}Moved ${moved_bytes} bytes to domain files${NC}"
    echo ""
    echo -e "${YELLOW}âš ï¸  Important: You need to manually update MEMORY.md${NC}"
    echo "Replace moved sections with brief summaries + references:"
    echo '  > Details: memory/domains/<name>.md (memory_search)'
    echo ""
    echo "Then verify: memorybox health"
  fi
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ARCHIVE: Move old daily logs
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cmd_archive() {
  validate_workspace

  echo -e "${BOLD}ğŸ—„ï¸  MemoryBox Archive${NC}"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "Archiving daily logs older than ${ARCHIVE_DAYS} days"
  echo ""

  mkdir -p "$MEMORY_DIR/archive"

  local archived=0
  while IFS= read -r f; do
    local name
    name=$(basename "$f")
    mv "$f" "$MEMORY_DIR/archive/"
    echo -e "   ${DIM}â†’ archive/${name}${NC}"
    archived=$((archived + 1))
  done < <(find "$MEMORY_DIR" -maxdepth 1 -name "202?-??-??.md" -mtime +${ARCHIVE_DAYS} 2>/dev/null | sort)

  echo ""
  if [[ $archived -gt 0 ]]; then
    echo -e "${GREEN}âœ… Archived ${archived} files${NC}"
  else
    echo -e "${GREEN}âœ… Nothing to archive â€” all logs are within ${ARCHIVE_DAYS} days${NC}"
  fi
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# REPORT: Before/After impact report
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cmd_report() {
  validate_workspace

  echo -e "${BOLD}ğŸ“Š MemoryBox Impact Report${NC}"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""

  local memory_size=0
  if [[ -f "$MEMORY_FILE" ]]; then
    memory_size=$(wc -c < "$MEMORY_FILE")
  fi

  # Count domain files
  local domain_size=0
  if [[ -d "$MEMORY_DIR/domains" ]]; then
    domain_size=$(find "$MEMORY_DIR/domains" -name "*.md" -exec cat {} + 2>/dev/null | wc -c | tr -d ' ')
  fi

  local total_managed=$((memory_size + domain_size))
  local sessions_per_day=200  # estimate: 48 crons * ~4 runs + channel messages

  echo -e "${BOLD}Tier 1 (auto-loaded everywhere):${NC}"
  echo "   MEMORY.md: ${memory_size} bytes"
  echo ""
  echo -e "${BOLD}Tier 2 (searched on-demand):${NC}"
  echo "   domains/: ${domain_size} bytes"
  echo ""
  echo -e "${BOLD}Without MemoryBox (flat):${NC}"
  echo "   Every session loads: ${total_managed} bytes"
  echo "   Daily: ${total_managed} Ã— ${sessions_per_day} = $((total_managed * sessions_per_day / 1024)) KB/day"
  echo ""
  echo -e "${BOLD}With MemoryBox (tiered):${NC}"
  echo "   Every session loads: ${memory_size} bytes"
  echo "   Daily: ${memory_size} Ã— ${sessions_per_day} = $((memory_size * sessions_per_day / 1024)) KB/day"
  echo "   On-demand searches: ~10/day Ã— ${domain_size} bytes = $((domain_size * 10 / 1024)) KB/day"
  echo ""

  if [[ $total_managed -gt 0 ]]; then
    local saved=$((total_managed - memory_size))
    local saved_pct=$((saved * 100 / total_managed))
    local daily_saved_kb=$(( (saved * sessions_per_day - domain_size * 10) / 1024 ))

    echo -e "${GREEN}ğŸ’° Savings:${NC}"
    echo -e "   Per session: ${saved} bytes saved (${saved_pct}%)"
    echo -e "   Per day: ~${daily_saved_kb} KB saved"

    # Cost estimate (Claude Sonnet 4.5: $3/MTok input)
    local monthly_saved_tokens=$((daily_saved_kb * 30 * 1024 / 4))  # ~4 chars per token
    local monthly_cost_cents=$((monthly_saved_tokens * 3 / 10000))   # $3/MTok in cents
    echo -e "   Est. monthly: ~\$0.${monthly_cost_cents} saved (Sonnet 4.5 pricing)"
  fi

  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# HEALTH: Quick health check
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cmd_health() {
  validate_workspace

  echo -e "${BOLD}ğŸ¥ MemoryBox Health Check${NC}"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""

  local score=100
  local issues=0

  # Check 1: MEMORY.md size
  if [[ -f "$MEMORY_FILE" ]]; then
    local size
    size=$(wc -c < "$MEMORY_FILE")
    local pct=$((size * 100 / MAX_MEMORY_BYTES))
    if [[ $size -gt $MAX_MEMORY_BYTES ]]; then
      echo -e "  ${RED}âœ— MEMORY.md over limit: ${size} bytes (${pct}%)${NC}"
      score=$((score - 30))
      issues=$((issues + 1))
    elif [[ $pct -gt $WARN_THRESHOLD ]]; then
      echo -e "  ${YELLOW}â–³ MEMORY.md warning: ${size} bytes (${pct}%)${NC}"
      score=$((score - 10))
    else
      echo -e "  ${GREEN}âœ“ MEMORY.md: ${size} bytes (${pct}%)${NC}"
    fi
  else
    echo -e "  ${YELLOW}â–³ MEMORY.md not found${NC}"
    score=$((score - 5))
  fi

  # Check 2: domains/ directory
  if [[ -d "$MEMORY_DIR/domains" ]]; then
    local domain_count
    domain_count=$(find "$MEMORY_DIR/domains" -name "*.md" 2>/dev/null | wc -l | tr -d ' ')
    echo -e "  ${GREEN}âœ“ domains/: ${domain_count} files${NC}"
  else
    echo -e "  ${YELLOW}â–³ domains/ not found â€” create with: mkdir -p memory/domains${NC}"
    score=$((score - 15))
    issues=$((issues + 1))
  fi

  # Check 3: Old daily logs
  if [[ -d "$MEMORY_DIR" ]]; then
    local old_count
    old_count=$(find "$MEMORY_DIR" -maxdepth 1 -name "202?-??-??.md" -mtime +${ARCHIVE_DAYS} 2>/dev/null | wc -l | tr -d ' ')
    if [[ $old_count -gt 0 ]]; then
      echo -e "  ${YELLOW}â–³ ${old_count} daily logs need archiving (>${ARCHIVE_DAYS} days)${NC}"
      score=$((score - 5))
    else
      echo -e "  ${GREEN}âœ“ Daily logs up to date${NC}"
    fi
  fi

  # Check 4: Flat files in root
  local flat_count=0
  if [[ -d "$MEMORY_DIR" ]]; then
    while IFS= read -r f; do
      local bn
      bn=$(basename "$f")
      [[ "$bn" =~ ^202[0-9]-[0-9]{2}-[0-9]{2}\.md$ ]] && continue
      [[ "$bn" == "README.md" ]] && continue
      flat_count=$((flat_count + 1))
    done < <(find "$MEMORY_DIR" -maxdepth 1 -name "*.md" -not -name "README.md" 2>/dev/null)

    if [[ $flat_count -gt 0 ]]; then
      echo -e "  ${YELLOW}â–³ ${flat_count} unorganized files in memory/ root${NC}"
      score=$((score - 10))
      issues=$((issues + 1))
    else
      echo -e "  ${GREEN}âœ“ memory/ root is clean${NC}"
    fi
  fi

  # Check 5: archive/ exists
  if [[ -d "$MEMORY_DIR/archive" ]]; then
    echo -e "  ${GREEN}âœ“ archive/ exists${NC}"
  else
    echo -e "  ${YELLOW}â–³ archive/ not found${NC}"
    score=$((score - 5))
  fi

  echo ""

  # Score display
  if [[ $score -ge 90 ]]; then
    echo -e "  ${GREEN}${BOLD}Health Score: ${score}/100 âœ¨ Excellent${NC}"
  elif [[ $score -ge 70 ]]; then
    echo -e "  ${YELLOW}${BOLD}Health Score: ${score}/100 ğŸ‘ Good${NC}"
  elif [[ $score -ge 50 ]]; then
    echo -e "  ${YELLOW}${BOLD}Health Score: ${score}/100 âš ï¸ Needs Work${NC}"
  else
    echo -e "  ${RED}${BOLD}Health Score: ${score}/100 ğŸš¨ Critical${NC}"
  fi

  if [[ $issues -gt 0 ]]; then
    echo ""
    echo -e "  ${DIM}Run 'memorybox analyze' for detailed recommendations${NC}"
  fi

  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DEDUPE: Find duplicate/similar content
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cmd_dedupe() {
  validate_workspace

  echo -e "${BOLD}ğŸ” MemoryBox Duplicate Detector${NC}"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""

  local found=0

  # Method 1: Exact line duplicates across files
  echo -e "${BOLD}1. Exact Duplicate Lines${NC}"
  echo ""

  local tmpfile
  tmpfile=$(mktemp)

  # Collect all non-empty, non-header lines from memory files
  # Filter out common false positives: table separators, code fences, list markers, URLs, short content
  find "$MEMORY_DIR" -name "*.md" -not -path "*/archive/*" 2>/dev/null | while read -r f; do
    grep -n "^[^#].\{30,\}" "$f" 2>/dev/null | while IFS=: read -r linenum content; do
      # Normalize whitespace
      local normalized
      normalized=$(echo "$content" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
      # Skip common patterns that aren't real duplicates
      [[ -z "$normalized" ]] && continue
      [[ "$normalized" =~ ^[\|\-\+\=\:[:space:]]+$ ]] && continue  # table separators
      [[ "$normalized" =~ ^\`\`\` ]] && continue                    # code fences
      [[ "$normalized" =~ ^[\-\*]\ \*\* ]] && continue              # bold list items (common template)
      [[ "$normalized" =~ ^[\-\*\>[:space:]]+$ ]] && continue       # empty list/quote markers
      [[ "$normalized" =~ ^\|.*\|.*\|.*\| ]] && continue            # table rows
      echo "${normalized}|$(basename "$f"):${linenum}" >> "$tmpfile"
    done
  done

  # Also check MEMORY.md
  if [[ -f "$MEMORY_FILE" ]]; then
    grep -n "^[^#].\{30,\}" "$MEMORY_FILE" 2>/dev/null | while IFS=: read -r linenum content; do
      local normalized
      normalized=$(echo "$content" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
      [[ -z "$normalized" ]] && continue
      [[ "$normalized" =~ ^[\|\-\+\=\:[:space:]]+$ ]] && continue
      [[ "$normalized" =~ ^\`\`\` ]] && continue
      [[ "$normalized" =~ ^[\-\*]\ \*\* ]] && continue
      [[ "$normalized" =~ ^[\-\*\>[:space:]]+$ ]] && continue
      [[ "$normalized" =~ ^\|.*\|.*\|.*\| ]] && continue
      echo "${normalized}|MEMORY.md:${linenum}" >> "$tmpfile"
    done
  fi

  # Find duplicates
  local dup_count=0
  sort "$tmpfile" | cut -d'|' -f1 | uniq -d | head -20 | while read -r dup_line; do
    dup_count=$((dup_count + 1))
    local short_line="${dup_line:0:60}"
    echo -e "   ${YELLOW}âš ï¸  \"${short_line}...\"${NC}"
    grep -F -- "$dup_line" "$tmpfile" | cut -d'|' -f2 | while read -r loc; do
      echo -e "      ${DIM}â†’ ${loc}${NC}"
    done
    echo ""
  done

  if [[ $dup_count -eq 0 ]]; then
    echo -e "   ${GREEN}âœ… No exact duplicates found${NC}"
  fi
  echo ""

  # Method 2: Similar section headers
  echo -e "${BOLD}2. Similar Section Headers${NC}"
  echo ""

  local headers_file
  headers_file=$(mktemp)

  # Collect all ## headers
  find "$MEMORY_DIR" -name "*.md" -not -path "*/archive/*" 2>/dev/null | while read -r f; do
    grep -n "^## " "$f" 2>/dev/null | while IFS=: read -r linenum header; do
      echo "$(basename "$f"):${linenum}|${header}" >> "$headers_file"
    done
  done

  if [[ -f "$MEMORY_FILE" ]]; then
    grep -n "^## " "$MEMORY_FILE" 2>/dev/null | while IFS=: read -r linenum header; do
      echo "MEMORY.md:${linenum}|${header}" >> "$headers_file"
    done
  fi

  # Find headers that appear in multiple files
  sort "$headers_file" | cut -d'|' -f2 | sort | uniq -d | while read -r dup_header; do
    echo -e "   ${YELLOW}âš ï¸  \"${dup_header}\" appears in:${NC}"
    grep -F -- "$dup_header" "$headers_file" | cut -d'|' -f1 | while read -r loc; do
      echo -e "      ${DIM}â†’ ${loc}${NC}"
    done
    echo ""
    found=$((found + 1))
  done

  if [[ $found -eq 0 ]]; then
    echo -e "   ${GREEN}âœ… No duplicate headers found${NC}"
  fi

  # Method 3: Files with similar names
  echo ""
  echo -e "${BOLD}3. Potentially Redundant Files${NC}"
  echo ""

  local similar=0
  find "$MEMORY_DIR" -name "*.md" -not -path "*/archive/*" 2>/dev/null | while read -r f; do
    local bn
    bn=$(basename "$f" .md)
    # Check for files with same base name in different dirs
    local matches
    matches=$(find "$MEMORY_DIR" -name "${bn}*" -not -path "$f" -not -path "*/archive/*" 2>/dev/null | wc -l | tr -d ' ')
    if [[ $matches -gt 0 ]]; then
      echo -e "   ${YELLOW}âš ï¸  $(basename "$f") has ${matches} similar file(s):${NC}"
      find "$MEMORY_DIR" -name "${bn}*" -not -path "$f" -not -path "*/archive/*" 2>/dev/null | while read -r m; do
        echo -e "      ${DIM}â†’ ${m#$MEMORY_DIR/}${NC}"
      done
      echo ""
      similar=$((similar + 1))
    fi
  done

  if [[ $similar -eq 0 ]]; then
    echo -e "   ${GREEN}âœ… No potentially redundant files found${NC}"
  fi

  rm -f "$tmpfile" "$headers_file"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# STALE: Find stale/outdated content
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cmd_stale() {
  validate_workspace

  echo -e "${BOLD}â³ MemoryBox Staleness Detector${NC}"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""

  local today_epoch
  today_epoch=$(date +%s)

  # 1. Files not modified in 30+ days
  echo -e "${BOLD}1. Stale Files (not modified in 30+ days)${NC}"
  echo ""

  local stale_count=0
  while IFS= read -r f; do
    local days_old=0
    if [[ "$(uname)" == "Darwin" ]]; then
      local mod_epoch
      mod_epoch=$(stat -f "%m" "$f" 2>/dev/null || echo 0)
      days_old=$(( (today_epoch - mod_epoch) / 86400 ))
    else
      local mod_epoch
      mod_epoch=$(stat -c "%Y" "$f" 2>/dev/null || echo 0)
      days_old=$(( (today_epoch - mod_epoch) / 86400 ))
    fi

    if [[ $days_old -gt 30 ]]; then
      echo -e "   ${YELLOW}${days_old}d old${NC} â€” ${f#$MEMORY_DIR/}"
      stale_count=$((stale_count + 1))
    fi
  done < <(find "$MEMORY_DIR" -name "*.md" -not -path "*/archive/*" -not -name "202?-??-??.md" 2>/dev/null)

  if [[ $stale_count -eq 0 ]]; then
    echo -e "   ${GREEN}âœ… All files modified within 30 days${NC}"
  else
    echo ""
    echo -e "   ${DIM}Consider archiving stale files: memorybox archive${NC}"
  fi
  echo ""

  # 2. Date references in MEMORY.md that may be outdated
  echo -e "${BOLD}2. Potentially Outdated Date References in MEMORY.md${NC}"
  echo ""

  if [[ -f "$MEMORY_FILE" ]]; then
    local outdated=0
    { grep -n "[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}" "$MEMORY_FILE" 2>/dev/null || true; } | while IFS=: read -r linenum content; do
      # Extract dates
      { echo "$content" | grep -o "[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}" || true; } | while read -r ref_date; do
        if [[ "$ref_date" < "2026-01-01" ]]; then
          echo -e "   ${YELLOW}Line ${linenum}: ${ref_date}${NC} â€” ${content:0:60}..."
          outdated=$((outdated + 1))
        fi
      done
    done

    # Check for "Updated" timestamps older than 7 days
    { grep -in "updated\|ê°±ì‹ \|ì—…ë°ì´íŠ¸" "$MEMORY_FILE" 2>/dev/null || true; } | while IFS=: read -r linenum content; do
      local ref_date
      ref_date=$(echo "$content" | grep -o "[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}" | head -1 || true)
      if [[ -n "$ref_date" ]]; then
        local ref_epoch=0
        if [[ "$(uname)" == "Darwin" ]]; then
          ref_epoch=$(date -j -f "%Y-%m-%d" "$ref_date" +%s 2>/dev/null || echo 0)
        else
          ref_epoch=$(date -d "$ref_date" +%s 2>/dev/null || echo 0)
        fi
        if [[ $ref_epoch -gt 0 ]]; then
          local days_ago=$(( (today_epoch - ref_epoch) / 86400 ))
          if [[ $days_ago -gt 7 ]]; then
            echo -e "   ${YELLOW}Line ${linenum}: \"Updated\" ${days_ago} days ago${NC}"
            echo -e "   ${DIM}${content:0:70}${NC}"
          fi
        fi
      fi
    done
  fi

  echo ""

  # 3. Domain files freshness
  echo -e "${BOLD}3. Domain Files Freshness${NC}"
  echo ""

  if [[ -d "$MEMORY_DIR/domains" ]]; then
    find "$MEMORY_DIR/domains" -name "*.md" 2>/dev/null | sort | while read -r f; do
      local days_old=0
      if [[ "$(uname)" == "Darwin" ]]; then
        local mod_epoch
        mod_epoch=$(stat -f "%m" "$f" 2>/dev/null || echo 0)
        days_old=$(( (today_epoch - mod_epoch) / 86400 ))
      else
        local mod_epoch
        mod_epoch=$(stat -c "%Y" "$f" 2>/dev/null || echo 0)
        days_old=$(( (today_epoch - mod_epoch) / 86400 ))
      fi

      local size
      size=$(wc -c < "$f" | tr -d ' ')
      local name
      name=$(basename "$f")

      if [[ $days_old -gt 14 ]]; then
        echo -e "   ${YELLOW}âš ï¸  ${name}${NC} â€” ${days_old}d old, ${size} bytes"
      else
        echo -e "   ${GREEN}âœ“  ${name}${NC} â€” ${days_old}d old, ${size} bytes"
      fi
    done
  fi

  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SUGGEST: Smart suggestions for improvement
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cmd_suggest() {
  validate_workspace

  echo -e "${BOLD}ğŸ’¡ MemoryBox Smart Suggestions${NC}"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""

  local suggestions=0

  # 1. MEMORY.md sections that could be domain files
  if [[ -f "$MEMORY_FILE" ]]; then
    local total_bytes
    total_bytes=$(wc -c < "$MEMORY_FILE")

    # Find large sections
    local current_section=""
    local current_size=0
    local section_line=0

    while IFS= read -r line; do
      section_line=$((section_line + 1))
      if [[ "$line" =~ ^##[[:space:]] ]]; then
        if [[ $current_size -gt 1500 && -n "$current_section" ]]; then
          local slug
          slug=$(echo "$current_section" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g')
          local domain_file="$MEMORY_DIR/domains/${slug}.md"
          if [[ ! -f "$domain_file" ]]; then
            echo -e "  ${CYAN}ğŸ“Œ Split suggestion:${NC} \"${current_section}\" (${current_size} bytes)"
            echo -e "     ${DIM}â†’ memory/domains/${slug}.md${NC}"
            echo -e "     ${DIM}Replace with 2-line summary + reference in MEMORY.md${NC}"
            echo ""
            suggestions=$((suggestions + 1))
          fi
        fi
        current_section="${line#\#\# }"
        current_size=${#line}
      else
        current_size=$((current_size + ${#line} + 1))
      fi
    done < "$MEMORY_FILE"

    # Check last section
    if [[ $current_size -gt 1500 && -n "$current_section" ]]; then
      local slug
      slug=$(echo "$current_section" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g')
      local domain_file="$MEMORY_DIR/domains/${slug}.md"
      if [[ ! -f "$domain_file" ]]; then
        echo -e "  ${CYAN}ğŸ“Œ Split suggestion:${NC} \"${current_section}\" (${current_size} bytes)"
        echo -e "     ${DIM}â†’ memory/domains/${slug}.md${NC}"
        echo ""
        suggestions=$((suggestions + 1))
      fi
    fi
  fi

  # 2. Missing recommended domain files
  echo -e "${BOLD}Recommended domain files:${NC}"
  echo ""
  for rec in "persona:Response style and formatting rules" \
             "decisions:Past decisions and lessons learned" \
             "milestones:Achievements and project history" \
             "system-preferences:API keys, integrations, config"; do
    local name="${rec%%:*}"
    local desc="${rec#*:}"
    if [[ -f "$MEMORY_DIR/domains/${name}.md" ]]; then
      echo -e "  ${GREEN}âœ“${NC} domains/${name}.md â€” ${desc}"
    else
      echo -e "  ${YELLOW}âœ—${NC} domains/${name}.md â€” ${desc}"
      echo -e "    ${DIM}Create with: memorybox split${NC}"
      suggestions=$((suggestions + 1))
    fi
  done
  echo ""

  # 3. Check for unorganized files
  local flat_count=0
  if [[ -d "$MEMORY_DIR" ]]; then
    while IFS= read -r f; do
      local bn
      bn=$(basename "$f")
      [[ "$bn" =~ ^202[0-9]-[0-9]{2}-[0-9]{2}\.md$ ]] && continue
      [[ "$bn" == "README.md" ]] && continue
      flat_count=$((flat_count + 1))
    done < <(find "$MEMORY_DIR" -maxdepth 1 -name "*.md" -not -name "README.md" 2>/dev/null)
  fi

  if [[ $flat_count -gt 0 ]]; then
    echo -e "  ${YELLOW}ğŸ“ ${flat_count} files in memory/ root need organizing${NC}"
    echo -e "     ${DIM}Run: memorybox analyze${NC}"
    echo ""
    suggestions=$((suggestions + 1))
  fi

  # 4. Archive suggestion
  if [[ -d "$MEMORY_DIR" ]]; then
    local old_count
    old_count=$(find "$MEMORY_DIR" -maxdepth 1 -name "202?-??-??.md" -mtime +${ARCHIVE_DAYS} 2>/dev/null | wc -l | tr -d ' ')
    if [[ $old_count -gt 0 ]]; then
      echo -e "  ${YELLOW}ğŸ—„ï¸  ${old_count} daily logs ready for archiving${NC}"
      echo -e "     ${DIM}Run: memorybox archive${NC}"
      echo ""
      suggestions=$((suggestions + 1))
    fi
  fi

  # Summary
  if [[ $suggestions -eq 0 ]]; then
    echo -e "  ${GREEN}âœ¨ No suggestions â€” your memory is well-organized!${NC}"
  else
    echo -e "  ${CYAN}${suggestions} suggestion(s) to improve your memory structure${NC}"
  fi

  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# INIT: Initialize 3-Tier structure
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cmd_init() {
  echo -e "${BOLD}ğŸ§  MemoryBox Init${NC}"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo -e "${DIM}Workspace: $WORKSPACE${NC}"
  echo ""

  # Create workspace if needed
  if [[ ! -d "$WORKSPACE" ]]; then
    echo -e "${YELLOW}Workspace not found. Create it? [Y/n]${NC}"
    read -rp "" answer
    case "$answer" in
      n|N) echo "Aborted."; exit 0 ;;
      *) mkdir -p "$WORKSPACE" ;;
    esac
  fi

  # Create directory structure
  local dirs=("memory" "memory/domains" "memory/projects" "memory/drafts" "memory/reports" "memory/incidents" "memory/archive")
  local created=0

  for d in "${dirs[@]}"; do
    if [[ ! -d "$WORKSPACE/$d" ]]; then
      mkdir -p "$WORKSPACE/$d"
      echo -e "  ${GREEN}+${NC} $d/"
      created=$((created + 1))
    else
      echo -e "  ${DIM}âœ“${NC} ${DIM}$d/ (exists)${NC}"
    fi
  done
  echo ""

  # Create MEMORY.md from template if not exists
  if [[ ! -f "$MEMORY_FILE" ]]; then
    local template_dir
    template_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)/templates"
    if [[ -f "$template_dir/MEMORY.md.template" ]]; then
      cp "$template_dir/MEMORY.md.template" "$MEMORY_FILE"
      echo -e "  ${GREEN}+${NC} MEMORY.md (from template)"
    else
      cat > "$MEMORY_FILE" << 'TMPL'
# Long-term Memory

> Core facts only. Target: â‰¤10KB. Loaded by every session.
> Detailed reference â†’ memory/domains/*.md (use memory_search)

## Critical Rules

## Owner Profile

## System Preferences

## Communication Style

## Important Decisions

## Notes
- Memory files: `memory/YYYY-MM-DD.md` (daily logs)
- Domain files: `memory/domains/*.md` (topic reference)
- Archive: `memory/archive/` (old data)
TMPL
      echo -e "  ${GREEN}+${NC} MEMORY.md (default template)"
    fi
    created=$((created + 1))
  else
    echo -e "  ${DIM}âœ“${NC} ${DIM}MEMORY.md (exists, $(wc -c < "$MEMORY_FILE" | tr -d ' ') bytes)${NC}"
  fi

  # Create domain templates if not exist
  for domain in persona decisions milestones; do
    local target="$MEMORY_DIR/domains/${domain}.md"
    if [[ ! -f "$target" ]]; then
      local template_dir
      template_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)/templates"
      local tpl="$template_dir/memory/domains/${domain}.md.template"
      if [[ -f "$tpl" ]]; then
        cp "$tpl" "$target"
      else
        echo "# ${domain^}" > "$target"
        echo "" >> "$target"
        echo "> Searchable via memory_search." >> "$target"
      fi
      echo -e "  ${GREEN}+${NC} memory/domains/${domain}.md"
      created=$((created + 1))
    else
      echo -e "  ${DIM}âœ“${NC} ${DIM}memory/domains/${domain}.md (exists)${NC}"
    fi
  done

  # Create memory README
  if [[ ! -f "$MEMORY_DIR/README.md" ]]; then
    local template_dir
    template_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)/templates"
    if [[ -f "$template_dir/memory/README.md" ]]; then
      cp "$template_dir/memory/README.md" "$MEMORY_DIR/README.md"
    fi
    echo -e "  ${GREEN}+${NC} memory/README.md"
    created=$((created + 1))
  fi

  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  if [[ $created -gt 0 ]]; then
    echo -e "${GREEN}âœ… Created ${created} items. 3-Tier structure ready!${NC}"
  else
    echo -e "${GREEN}âœ… Already initialized â€” nothing to create.${NC}"
  fi
  echo ""
  echo "Next: Run 'memorybox health' to verify."
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DOCTOR: Full diagnostic
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cmd_doctor() {
  validate_workspace

  echo -e "${BOLD}ğŸ©º MemoryBox Doctor â€” Full Diagnostic${NC}"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo -e "${DIM}Workspace: $WORKSPACE${NC}"
  echo -e "${DIM}$(date '+%Y-%m-%d %H:%M:%S')${NC}"
  echo ""

  # 1. Health
  echo -e "${BOLD}[1/5] Health Check${NC}"
  echo ""
  cmd_health 2>/dev/null | grep -E "âœ“|âœ—|â–³|Score" | sed 's/^/  /'
  echo ""

  # 2. Analyze (brief)
  echo -e "${BOLD}[2/5] Size Analysis${NC}"
  echo ""
  if [[ -f "$MEMORY_FILE" ]]; then
    local size
    size=$(wc -c < "$MEMORY_FILE")
    local pct=$((size * 100 / MAX_MEMORY_BYTES))
    echo -e "  MEMORY.md: ${size} bytes (${pct}%)"

    local domain_size=0
    if [[ -d "$MEMORY_DIR/domains" ]]; then
      domain_size=$(find "$MEMORY_DIR/domains" -name "*.md" -exec cat {} + 2>/dev/null | wc -c | tr -d ' ')
    fi
    echo -e "  domains/: ${domain_size} bytes"
    echo -e "  Total managed: $((size + domain_size)) bytes"

    if [[ $size -gt $MAX_MEMORY_BYTES ]]; then
      echo -e "  ${RED}â†’ MEMORY.md over limit! Run: memorybox split${NC}"
    fi
  fi
  echo ""

  # 3. Duplicates (brief)
  echo -e "${BOLD}[3/5] Duplicate Check${NC}"
  echo ""

  local tmpfile
  tmpfile=$(mktemp)
  find "$MEMORY_DIR" -name "*.md" -not -path "*/archive/*" 2>/dev/null | while read -r f; do
    grep "^[^#].\{30,\}" "$f" 2>/dev/null | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
  done | grep -vE '^[\|\-\+\=\:[:space:]]+$' | grep -vE '^\`\`\`' | grep -vE '^\|.*\|.*\|.*\|' | grep -vE '^[â”Œâ””â”œâ”â”˜â”¤â”¬â”´â”¼â”€â”‚â”]+' | grep -vE '^(https?://|curl |if \[|fi$)' | sort | uniq -d | wc -l > "$tmpfile"

  local dup_count
  dup_count=$(cat "$tmpfile")
  rm -f "$tmpfile"

  if [[ $dup_count -gt 0 ]]; then
    echo -e "  ${YELLOW}âš ï¸  ${dup_count} potential duplicate lines${NC}"
    echo -e "  ${DIM}Run: memorybox dedupe${NC}"
  else
    echo -e "  ${GREEN}âœ… No duplicates${NC}"
  fi
  echo ""

  # 4. Stale Check (brief)
  echo -e "${BOLD}[4/5] Stale Content${NC}"
  echo ""

  local stale_count=0
  if [[ -d "$MEMORY_DIR/domains" ]]; then
    while IFS= read -r f; do
      local mod_days
      if [[ "$(uname)" == "Darwin" ]]; then
        mod_days=$(( ( $(date +%s) - $(stat -f %m "$f") ) / 86400 ))
      else
        mod_days=$(( ( $(date +%s) - $(stat -c %Y "$f") ) / 86400 ))
      fi
      if [[ $mod_days -gt 60 ]]; then
        stale_count=$((stale_count + 1))
      fi
    done < <(find "$MEMORY_DIR/domains" -name "*.md" 2>/dev/null)
  fi

  if [[ $stale_count -gt 0 ]]; then
    echo -e "  ${YELLOW}â° ${stale_count} domain file(s) unchanged for 60+ days${NC}"
    echo -e "  ${DIM}Run: memorybox stale${NC}"
  else
    echo -e "  ${GREEN}âœ… All content is fresh${NC}"
  fi
  echo ""

  # 5. Suggestions (brief)
  echo -e "${BOLD}[5/5] Suggestions${NC}"
  echo ""

  local sug_count=0

  # Check for large sections
  if [[ -f "$MEMORY_FILE" ]]; then
    local large_sections=0
    local current_section=""
    local current_size=0
    while IFS= read -r line; do
      if [[ "$line" =~ ^##[[:space:]] ]]; then
        if [[ $current_size -gt 2000 && -n "$current_section" ]]; then
          large_sections=$((large_sections + 1))
        fi
        current_section="${line#\#\# }"
        current_size=${#line}
      else
        current_size=$((current_size + ${#line} + 1))
      fi
    done < "$MEMORY_FILE"
    if [[ $current_size -gt 2000 && -n "$current_section" ]]; then
      large_sections=$((large_sections + 1))
    fi

    if [[ $large_sections -gt 0 ]]; then
      echo -e "  ${YELLOW}ğŸ“Œ ${large_sections} section(s) could be split to domains/${NC}"
      sug_count=$((sug_count + large_sections))
    fi
  fi

  # Check old logs
  local old_count
  old_count=$(find "$MEMORY_DIR" -maxdepth 1 -name "202?-??-??.md" -mtime +${ARCHIVE_DAYS} 2>/dev/null | wc -l | tr -d ' ')
  if [[ $old_count -gt 0 ]]; then
    echo -e "  ${YELLOW}ğŸ—„ï¸  ${old_count} daily logs ready for archiving${NC}"
    sug_count=$((sug_count + 1))
  fi

  if [[ $sug_count -eq 0 ]]; then
    echo -e "  ${GREEN}âœ¨ No issues found${NC}"
  else
    echo -e ""
    echo -e "  ${DIM}Run: memorybox suggest (for details)${NC}"
  fi

  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo -e "${DIM}Full commands: analyze, split, dedupe, stale, suggest${NC}"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Command dispatch
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
case "$COMMAND" in
  analyze)  cmd_analyze ;;
  split)    cmd_split ;;
  archive)  cmd_archive ;;
  report)   cmd_report ;;
  health)   cmd_health ;;
  dedupe)   cmd_dedupe ;;
  stale)    cmd_stale ;;
  suggest)  cmd_suggest ;;
  init)     cmd_init ;;
  doctor)   cmd_doctor ;;
  help|-h)  usage ;;
  *)
    echo -e "${RED}Unknown command: $COMMAND${NC}"
    echo "Run 'memorybox --help' for usage"
    exit 1
    ;;
esac
